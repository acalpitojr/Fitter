/**
 * \file
 *
 * \brief SAM D20/D21 I2C Master Quick Start Guide with Callbacks
 *
 * Copyright (C) 2012-2014 Atmel Corporation. All rights reserved.
 *
 * \asf_license_start
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name of Atmel may not be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * 4. This software may only be redistributed and used in connection with an
 *    Atmel microcontroller product.
 *
 * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \asf_license_stop
 *
 */

#include <asf.h>
#include <system_interrupt.h>
#include "uart_bt.h"
#include "bt_uart_transport.h"


// Variable declaration
unsigned char TCU_HCI_RESET_REQ[4]											= {0x01, 0x03, 0x0c, 0x00};
unsigned char TCU_HCI_RESET_RESP[7]											= {0x04, 0x0e, 0x04, 0x04, 0x03, 0x0c, 0x00};
unsigned char TCU_HCI_GET_FIRMWARE_VERSION_REQ[13]							= {0x01, 0x08, 0xfc, 0x09, 0x00, 0xa1, 0x00, 0x00, 0x00, 0x14, 0x0d, 0xff, 0x00};
unsigned char TCU_HCI_M2_MESSAGE_SET_REQ[51]								= {0x01, 0x08, 0xfc, 0x2f, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x14, 0x55, 0xff, 0x10, 0x25, 0x01, 0xa4, 0x1e, 0x0a, 0x00, 0x01, 0x34, 0xb5, 0xf7, 0xab, 0xf8, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46};
unsigned char TCU_HCI_M2_MESSAGE_SET_REQ2[102]								= {0x01, 0x08, 0xfc, 0x62, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x14, 0x56, 0xff, 0x10, 0x58, 0x00, 0x70, 0x05, 0x00, 0x00, 0xb5, 0x01, 0x0a, 0x01, 0x91, 0x01, 0x06, 0x09, 0x0e, 0x00, 0x91, 0x2a, 0xf0, 0xbf, 0xfb, 0x0f, 0x4e, 0x05, 0x1c, 0x70, 0x88, 0xf0, 0x21, 0x88, 0x43, 0x10, 0x21, 0x08, 0x43, 0x70, 0x80, 0xfe, 0x20, 0x38, 0x40, 0xf0, 0x80, 0xf8, 0x20, 0xb0, 0x80, 0x10, 0x20, 0x4b, 0xf0, 0x4a, 0xf8, 0x01, 0x98, 0xf0, 0x80, 0x10, 0x20, 0x4b, 0xf0, 0x45, 0xf8, 0x00, 0x98, 0xf0, 0x80, 0x10, 0x20, 0x4b, 0xf0, 0x40, 0xf8, 0x01, 0xbc, 0x01, 0x48, 0x00, 0x47, 0x00, 0x00, 0xdb, 0x1e, 0x0a, 0x00, 0x80, 0x0f, 0x06, 0x00};
unsigned char TCU_HCI_M2_MESSAGE_SET_REQ3[15]								= {0x01, 0x08, 0xfc, 0x0b, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x14, 0x57, 0xff, 0x02, 0x01, 0x01};
unsigned char TCU_HCI_M2_MESSAGE_SET_REQ4[51]								= {0x01, 0x08, 0xfc, 0x2f, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x14, 0x55, 0xff, 0x10, 0x25, 0x02, 0x40, 0xc8, 0x09, 0x00, 0x20, 0x1c, 0xba, 0xf7, 0x88, 0xfc, 0x03, 0xe7, 0x11, 0xe0, 0x0c, 0xe0, 0xff, 0xe7, 0x20, 0x1c, 0x00, 0xf0, 0x9e, 0xfd, 0xfc, 0xe6, 0x20, 0x1c, 0x00, 0xf0, 0x9d, 0xfe, 0xf8, 0xe6, 0x20, 0x1c};
unsigned char TCU_HCI_M2_MESSAGE_SET_REQ5[254]								= {0x01, 0x08, 0xfc, 0xfa, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x14, 0x56, 0xff, 0x10, 0xf0, 0x80, 0x70, 0x05, 0x00, 0xff, 0xb5, 0xfe, 0x21, 0x08, 0x40, 0x83, 0xb0, 0x02, 0x90, 0x10, 0x0a, 0x15, 0x06, 0x2d, 0x0e, 0x14, 0x1c, 0x01, 0x90, 0x10, 0x1c, 0x2a, 0xf0, 0x7a, 0xfb, 0x53, 0x4f, 0x06, 0x1c, 0x78, 0x88, 0xf0, 0x21, 0x88, 0x43, 0x10, 0x21, 0x08, 0x43, 0x78, 0x80, 0x02, 0x98, 0xf8, 0x80, 0xf8, 0x20, 0xb8, 0x80, 0x10, 0x20, 0x4b, 0xf0, 0x06, 0xf8, 0x01, 0x98, 0xf8, 0x80, 0x10, 0x20, 0x4b, 0xf0, 0x01, 0xf8, 0xfd, 0x80, 0x10, 0x20, 0x4a, 0xf0, 0xfd, 0xff, 0x06, 0x98, 0x00, 0x25, 0x00, 0x28, 0x34, 0xd9, 0x30, 0x78, 0xf8, 0x80, 0x10, 0x20, 0x4a, 0xf0, 0xf4, 0xff, 0x01, 0x34, 0x24, 0x04, 0x24, 0x0c, 0x01, 0x36, 0x20, 0x07, 0x06, 0xd0, 0x20, 0x07, 0x00, 0x0f, 0x08, 0x28, 0x1f, 0xd1, 0x04, 0x98, 0x00, 0x28, 0x1c, 0xd1, 0x4a, 0xf0, 0x01, 0xfd, 0xd8, 0x20, 0xb8, 0x80, 0x20, 0x20, 0x4a, 0xf0, 0xe0, 0xff, 0x4a, 0xf0, 0x14, 0xfd, 0x02, 0x98, 0xf8, 0x80, 0xf8, 0x20, 0xb8, 0x80, 0x10, 0x20, 0x4a, 0xf0, 0xd7, 0xff, 0x20, 0x0a, 0x21, 0x06, 0x09, 0x0e, 0x00, 0x91, 0xf8, 0x80, 0x10, 0x20, 0x4a, 0xf0, 0xcf, 0xff, 0x00, 0x99, 0xf9, 0x80, 0x10, 0x20, 0x4a, 0xf0, 0xca, 0xff, 0x01, 0x35, 0x06, 0x98, 0x2d, 0x04, 0x2d, 0x0c, 0x85, 0x42, 0xca, 0xd3, 0x4a, 0xf0, 0xde, 0xfc, 0xd8, 0x20, 0xb8, 0x80, 0x20, 0x20, 0x4a, 0xf0, 0xbd, 0xff, 0x4a, 0xf0, 0xf1, 0xfc, 0x07, 0xb0, 0xf0, 0xbc, 0x08, 0xbc, 0x18, 0x47, 0xf8, 0xb5, 0x04, 0x1c, 0xc0, 0x7b, 0x10, 0x28, 0x02, 0xd1, 0x20, 0x7c, 0x04, 0x28, 0x06, 0xd0, 0x02, 0x21, 0x20, 0x1c, 0x45, 0xf0};
unsigned char TCU_HCI_M2_MESSAGE_SET_REQ6[154]								= {0x01, 0x08, 0xfc, 0x96, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x14, 0x56, 0xff, 0x10, 0x8c, 0x6c, 0x71, 0x05, 0x00, 0x25, 0xfe, 0xf8, 0xbc, 0x08, 0xbc, 0x18, 0x47, 0x60, 0x7c, 0x00, 0x90, 0x25, 0x7d, 0xa6, 0x7c, 0xe7, 0x7c, 0x00, 0x2d, 0x0a, 0xd0, 0x7e, 0x2d, 0x08, 0xd8, 0x01, 0x2e, 0x06, 0xd8, 0x78, 0x06, 0x40, 0x0e, 0x02, 0x28, 0x02, 0xd3, 0x40, 0x19, 0x80, 0x28, 0x04, 0xd9, 0x04, 0x21, 0x20, 0x1c, 0x45, 0xf0, 0x0c, 0xfe, 0xe5, 0xe7, 0x4a, 0xf0, 0x24, 0xfd, 0x00, 0x28, 0x04, 0xd1, 0xfe, 0x21, 0x20, 0x1c, 0x45, 0xf0, 0x03, 0xfe, 0xdc, 0xe7, 0x0d, 0x48, 0x00, 0x78, 0x01, 0x28, 0x02, 0xd1, 0x0c, 0x49, 0x00, 0x20, 0x48, 0x83, 0x2b, 0x1c, 0x3a, 0x1c, 0x00, 0x98, 0x31, 0x1c, 0xff, 0xf7, 0x59, 0xff, 0x07, 0x48, 0x00, 0x78, 0x01, 0x28, 0x01, 0xd1, 0x06, 0x49, 0x48, 0x83, 0x00, 0x21, 0x20, 0x1c, 0x45, 0xf0, 0xdb, 0xfd, 0x00, 0x21, 0xc1, 0x73, 0xc2, 0xe7, 0x80, 0x0f, 0x06, 0x00, 0x4c, 0x37, 0x05, 0x00, 0x60, 0x08, 0x06, 0x00};
unsigned char TCU_HCI_M2_MESSAGE_SET_REQ7[15]								= {0x01, 0x08, 0xfc, 0x0b, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x14, 0x57, 0xff, 0x02, 0x02, 0x01};
unsigned char TCU_HCI_M2_BTL_EEPROM_WRITE_ENABLE_REQ[13]					= {0x01, 0x08, 0xfc, 0x09, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x14, 0x83, 0xff, 0x00};
unsigned char TCU_HCI_M2_BTL_SET_I2C_ENABLE_REQ[15]							= {0x01, 0x08, 0xfc, 0x0b, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x14, 0x5b, 0xff, 0x02, 0x03, 0x01};
unsigned char TCU_HCI_M2_BTL_GET_ALLDATA_READ_E2PROM_REQ[17]				= {0x01, 0x08, 0xfc, 0x0d, 0x00, 0xa1, 0x00, 0x00, 0x00, 0x14, 0x5d, 0xff, 0x10, 0x03, 0xa0, 0x01, 0x00};
unsigned char TCU_HCI_READ_BD_ADDR_REQ[4]									= {0x01, 0x09, 0x10, 0x00};
unsigned char TCU_HCI_WRITE_BD_ADDR_REQ[10]									= {0x01, 0x13, 0x10, 0x06, 0x99, 0xe0, 0x07, 0x43, 0x13, 0x00};
unsigned char TCU_HCI_SET_MODE_REQ[7]										= {0x01, 0x08, 0xfc, 0x03, 0x00, 0x99, 0x01};
unsigned char TCU_MNG_INIT_REQ[17]											= {0x11, 0x00, 0x00, 0xe1, 0x01, 0x0a, 0x00, 0x04, 0x00, 0x07, 0x50, 0x41, 0x4e, 0x31, 0x30, 0x32, 0x36};
unsigned char TCU_MNG_STANDARD_HCI_SET_REQ_Write_Class_of_Device[13]		= {0x0d, 0x00, 0x00, 0xe1, 0x3d, 0x06, 0x00, 0x24, 0x0c, 0x03, 0x18, 0x11, 0xc0};
unsigned char TCU_SPP_SETUP_REQ[7]											= {0x07, 0x00, 0x00, 0xe5, 0x01, 0x00, 0x00};
unsigned char TCU_MNG_SET_SCAN_REQ[8]										= {0x08, 0x00, 0x00, 0xe1, 0x0c, 0x01, 0x00, 0x03};
unsigned char TCU_MNG_DISCOVER_REMOTE_SERVICE_REQ[15]						= {0x0f, 0x00, 0x00, 0xe1, 0x05, 0x08, 0x00, 0x00, 0x00, 0x13, 0x43, 0x09, 0x37, 0x33, 0x00};
unsigned char TCU_SPP_CONNECT_REQ[23]										= {0x17, 0x00, 0x00, 0xe5, 0x03, 0x10, 0x00, 0x00, 0x13, 0x43, 0x09, 0x37, 0x33, 0x07, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x00};
unsigned char TCU_MNG_SSP_SET_REQ_HCI_IO_Capability_Request_Reply[19]		= {0x13, 0x00, 0x00, 0xe1, 0x3d, 0x0c, 0x00, 0x2b, 0x04, 0x09, 0x00, 0x13, 0x43, 0x09, 0x37, 0x33, 0x01, 0x00, 0x03};
unsigned char TCU_MNG_SSP_SET_REQ_HCI_User_Confirmation_Request_Reply[17]	= {0x11, 0x00, 0x00, 0xe1, 0x3d, 0x0a, 0x00, 0x2c, 0x04, 0x06, 0x00, 0x13, 0x43, 0x09, 0x37, 0x33, 0x00};
unsigned char TCU_SPP_DATA_TRANSFER_REQ[21]									= {0x15, 0x00, 0x00, 0xe5, 0x08, 0x0e, 0x00, 0x0c, 0x00, 0x54, 0x45, 0x53, 0x54, 0x20, 0x50, 0x41, 0x4e, 0x31, 0x30, 0x32, 0x36};
unsigned char TCU_SPP_DISCONNECT_REQ[7]										= {0x07, 0x00, 0x00, 0xe5, 0x04, 0x00, 0x00};

//void i2c_write_T(uint8_t port);
static void usart_tx2_callback(const struct usart_module *const module);
static void usart_rx2_callback(const struct usart_module *const module);

//! [packet_data]
#define MAX_DATA_LENGTH 80

/* Structure for USART module connected to EDBG */
struct usart_module usart_module_bt;

/* Data for EDBG communication */
static uint8_t tx2_data[MAX_DATA_LENGTH];
static uint8_t au8BtUartRxData[MAX_DATA_LENGTH];

//static char bytBTBufferIndex=0;

void tc_enable_2(void);
void load_buffer_cdc(uint8_t data_value);

/**
 * \internal
 * \brief USART interrupt callback function
 *
 * Called by USART driver when transmit is complete.
 *
 * * \param module USART module causing the interrupt (not used)
 */
static void usart_tx2_callback(const struct usart_module *const module)
{
	/* Data ready to be sent */

		/* Transmit next data */
//		ui_com_rx_start();
//		tx2_data = udi_cdc_getc();
//		usart_write_buffer_job(&usart_module_bt, &tx2_data, 1);
}

/**
 * \internal
 * \brief USART interrupt callback function
 *
 * Called by USART driver when receiving is complete.
 *
 * * \param module USART module causing the interrupt (not used)
 */
static void usart_rx2_callback(const struct usart_module *const module)
{
	/* Data received */
        uint8_t rx_byte = 0;
		//usart_read_buffer_job(&usart_module_bt, &rx_byte, sizeof(rx_byte));
		rx_byte = *module->rx_buffer_ptr;
        bt_uart_manager(rx_byte);
		tc_enable_2();

	return;
}

static void usart_cts_callback(const struct usart_module *const module)
{
}


void configure_uart_bt(void)
{
	struct usart_config usart_conf_bt;
	struct port_config pin_conf; //rts PA19
	struct port_config Resetpin_conf;
	struct port_config CTSpin_conf; //CTS PA18
	bool pin_state = true;
	char bytA;
	
	static uint8_t buffer_AT[14]= {
	'A', 'T', '+', 'N', 'A', 'M', 'E', '=', 'F', 'i','t','t','e','r', 13};
//	static uint8_t buffer_AT2[18]= {
//	'A', 'T', '+', 'U', 'A', 'R', 'T', '=','9','6','0','0', ',', '1', ',', '0', 13, 10 };

	/* delay */
	delay_init();

	/* Configure USART for unit test output */
	usart_get_config_defaults(&usart_conf_bt);
	
	port_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_UP;
	
		port_get_config_defaults(&Resetpin_conf);
		Resetpin_conf.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
		Resetpin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_UP;
	
		port_get_config_defaults(&CTSpin_conf);
		Resetpin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
		Resetpin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_UP;
		port_pin_set_config(PIN_PA18, &CTSpin_conf);
	/* Options for USART. */
	usart_conf_bt.baudrate = 115200; //9600; //LE32_TO_CPU(cfg->dwDTERate);
	usart_conf_bt.mux_setting = USART_RX_1_TX_0_XCK_1;
	usart_conf_bt.pinmux_pad0 = PINMUX_PA16C_SERCOM1_PAD0;
	usart_conf_bt.pinmux_pad1 = PINMUX_PA17C_SERCOM1_PAD1;
	usart_conf_bt.pinmux_pad2 = PINMUX_DEFAULT;//PINMUX_PA18C_SERCOM1_PAD2;
	usart_conf_bt.pinmux_pad3 = PINMUX_DEFAULT;//PINMUX_PA19C_SERCOM1_PAD3;
	
//	usart_conf_bt.transfer_mode =

    usart_module_bt.rx_buffer_ptr = au8BtUartRxData; /* All recevied data from the uart will be placed in this buffer*/
	usart_init(&usart_module_bt, SERCOM1, &usart_conf_bt);
	usart_enable(&usart_module_bt);
	
	/* Enable interrupts */
	usart_register_callback(&usart_module_bt, usart_tx2_callback,
	USART_CALLBACK_BUFFER_TRANSMITTED);
	usart_enable_callback(&usart_module_bt, USART_CALLBACK_BUFFER_TRANSMITTED);
	usart_register_callback(&usart_module_bt, usart_rx2_callback,
	USART_CALLBACK_BUFFER_RECEIVED);
	usart_enable_callback(&usart_module_bt, USART_CALLBACK_BUFFER_RECEIVED);
	////usart_register_callback(&usart_module_bt, usart_cts_callback,
	////USART_CALLBACK_CTS_INPUT_CHANGE);
	////usart_enable_callback(&usart_module_bt, USART_CALLBACK_CTS_INPUT_CHANGE);
		pin_state = false;
	port_pin_set_config(PIN_PA19, &pin_conf);
	port_pin_set_output_level(PIN_PA19, pin_state);
	
	port_pin_set_config(PIN_PA07, &Resetpin_conf);
	pin_state = false;
	port_pin_set_output_level(PIN_PA07, pin_state);
	delay_cycles_ms(2000);
	pin_state = true;
	port_pin_set_output_level(PIN_PA07, pin_state);

//	usart_disable(&usart_module_bt);
	//Init_Pan1026();
	//Init_Pan1026();
	//while(1)
	//{
	//	Init_Pan1026();
	//	delay_cycles_ms(100);
	//}
	
}

void Init_Pan1026(void)
{
	usart_write_buffer_wait(&usart_module_bt,&TCU_HCI_RESET_REQ, sizeof(TCU_HCI_RESET_REQ)/sizeof(TCU_HCI_RESET_REQ[0]));
	//delay_cycles_ms(100);
	usart_read_buffer_wait(&usart_module_bt,&au8BtUartRxData,7);
	delay_cycles_ms(100);
	
	
		usart_write_buffer_wait(&usart_module_bt,&TCU_HCI_GET_FIRMWARE_VERSION_REQ, sizeof(TCU_HCI_GET_FIRMWARE_VERSION_REQ)/sizeof(TCU_HCI_GET_FIRMWARE_VERSION_REQ[0]));
		
		usart_read_buffer_wait(&usart_module_bt,&au8BtUartRxData,15);
		delay_cycles_ms(100);
}